âš¡  ð—§ð˜†ð—½ð—²ð˜€ ð—¼ð—³ ð—–ð—¼ð—»ð˜€ð˜ð—¿ð˜‚ð—°ð˜ð—¼ð—¿ð˜€ ð—¶ð—» ð—–#
#  Types of Constructors in C#

Here's the complete list of constructor types in C#:

## 1. **Default Constructor**
A parameterless constructor that initializes objects with default values
and not take any inputs.

``` 
public class Person
{
    public string Name;
    public int Age;
    
    public Person()  // Default constructor
    {
        Name = "Unknown";
        Age = 0;
    }
}
```

## 2. **Parameterized Constructor**
Accepts parameters to initialize objects with specific values.

```csharp
public class Person
{
    public string Name;
    public int Age;
    
    public Person(string name, int age)  // Parameterized constructor
    {
        Name = name;
        Age = age;
    }
}
```

## 3. **Copy Constructor**
Creates a new object by copying values from an existing object.

```csharp
public class Person
{
    public string Name;
    public int Age;
    
    public Person(Person other)  // Copy constructor
    {
        Name = other.Name;
        Age = other.Age;
    }
}
```

## 4. **Static Constructor**
Initializes static members of a class. Called automatically once before any static members are accessed.

```csharp
public class Configuration
{
    public static string AppName;
    
    static Configuration()  // Static constructor
    {
        AppName = "MyApp";
        Console.WriteLine("Static constructor called");
    }
}
```

## 5. **Private Constructor**
Prevents object creation from outside the class. Used for singleton patterns or utility classes.

```csharp
public class Singleton
{
    private static Singleton instance;
    
    private Singleton()  // Private constructor
    {
        // Initialization code
    }
    
    public static Singleton GetInstance()
    {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}
```

## 6. **Constructor Chaining**
When one constructor calls another using `this` or `base` keywords.

```csharp
public class Person
{
    public string Name;
    public int Age;
    
    public Person() : this("Unknown", 0)  // Calls another constructor
    {
    }
    
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}

// With inheritance
public class Employee : Person
{
    public int EmployeeId;
    
    public Employee(string name, int age, int id) : base(name, age)  // Calls base class constructor
    {
        EmployeeId = id;
    }
}
```

## 7. **Primary Constructor (C# 12+)**
Defined directly in the class declaration with parameters automatically available throughout the class.

```csharp
public class Person(string name, int age)  // Primary constructor
{
    public string Name { get; } = name;
    public int Age { get; } = age;
    
    public void Introduce()
    {
        Console.WriteLine($"Hi, I'm {name} and I'm {age} years old.");
    }
}

// Usage
var person = new Person("Alice", 30);
```

### Primary Constructor with Inheritance
```csharp
public class Animal(string name)
{
    public string Name { get; } = name;
}

public class Dog(string name, string breed) : Animal(name)
{
    public string Breed { get; } = breed;
}
```

---

Each constructor type serves a specific purpose in controlling object creation and initialization in C#, from basic initialization to advanced patterns like singletons and modern concise syntax.

Constructors are an essential functionality when writing code in the object-oriented approach.

They allow you to control the object's creation and how its members will be initialized

In C#, there are 6 types of constructors that you can use.
-------------------------------------------------------------
# When and Why Use These Constructors

## 1. **Private Constructor**

### When to Use
- **Singleton Pattern** - ensuring only one instance exists
- **Utility/Helper Classes** - classes with only static methods
- **Factory Pattern** - controlling object creation through factory methods
- **Preventing instantiation** - for classes that should never be instantiated

### Why Use

**Scenario 1: Singleton Pattern**
```csharp
public class DatabaseConnection
{
    private static DatabaseConnection instance;
    private static readonly object lockObject = new object();
    
    private DatabaseConnection()  // Private constructor
    {
        // Expensive initialization (connect to database)
        Console.WriteLine("Database connection established");
    }
    
    public static DatabaseConnection GetInstance()
    {
        if (instance == null)
        {
            lock (lockObject)
            {
                if (instance == null)
                    instance = new DatabaseConnection();
            }
        }
        return instance;
    }
}

// Usage
var db1 = DatabaseConnection.GetInstance();
var db2 = DatabaseConnection.GetInstance();
// db1 and db2 are the same instance - only one connection created
```

**Scenario 2: Utility Class**
```csharp
public class MathHelper
{
    private MathHelper() { }  // Prevent instantiation
    
    public static int Add(int a, int b) => a + b;
    public static int Multiply(int a, int b) => a * b;
}

// Usage
int result = MathHelper.Add(5, 3);
// var helper = new MathHelper(); // Compilation error!
```

**Scenario 3: Factory Pattern**
```csharp
public class Employee
{
    public string Name { get; set; }
    public decimal Salary { get; set; }
    
    private Employee() { }  // Force use of factory methods
    
    public static Employee CreateManager(string name)
    {
        return new Employee 
        { 
            Name = name, 
            Salary = 100000 
        };
    }
    
    public static Employee CreateDeveloper(string name)
    {
        return new Employee 
        { 
            Name = name, 
            Salary = 80000 
        };
    }
}

// Usage
var manager = Employee.CreateManager("Alice");
var dev = Employee.CreateDeveloper("Bob");
```

---

## 2. **Static Constructor**

### When to Use
- **Initialize static members** before they're used
- **Read configuration** that all instances need
- **Set up one-time resources** (database connections, file handles)
- **License validation** or initial checks

### Why Use

**Scenario 1: Initialize Static Fields**
```csharp
public class AppSettings
{
    public static string ConnectionString;
    public static int MaxRetries;
    public static DateTime AppStartTime;
    
    static AppSettings()  // Called once before any static member access
    {
        ConnectionString = "Server=localhost;Database=MyDB";
        MaxRetries = 3;
        AppStartTime = DateTime.Now;
        Console.WriteLine("App settings initialized");
    }
}

// First access triggers static constructor
string conn = AppSettings.ConnectionString;  // Static constructor runs here
```

**Scenario 2: Load Configuration**
```csharp
public class Logger
{
    public static string LogPath;
    public static LogLevel MinLevel;
    
    static Logger()
    {
        // Read from config file
        LogPath = ConfigurationManager.AppSettings["LogPath"] ?? "C:\\Logs";
        MinLevel = Enum.Parse<LogLevel>(
            ConfigurationManager.AppSettings["MinLogLevel"] ?? "Info"
        );
        
        // Create log directory if it doesn't exist
        Directory.CreateDirectory(LogPath);
    }
    
    public static void Log(string message, LogLevel level)
    {
        if (level >= MinLevel)
        {
            File.AppendAllText(
                Path.Combine(LogPath, "app.log"), 
                $"{DateTime.Now}: {message}\n"
            );
        }
    }
}
```

**Scenario 3: Initialize Lookup Tables**
```csharp
public class ErrorMessages
{
    public static Dictionary<int, string> Messages;
    
    static ErrorMessages()
    {
        Messages = new Dictionary<int, string>
        {
            { 404, "Page not found" },
            { 500, "Internal server error" },
            { 401, "Unauthorized access" },
            { 403, "Forbidden" }
        };
        
        Console.WriteLine($"Loaded {Messages.Count} error messages");
    }
}

// Usage
string error = ErrorMessages.Messages[404];
```

---

## 3. **Copy Constructor**

### When to Use
- **Deep copying objects** with reference types
- **Cloning objects** while preserving independence
- **Immutability patterns** - creating modified copies
- **Prototype pattern** implementations

### Why Use

**Scenario 1: Deep Copy (Avoiding Reference Issues)**
```csharp
public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
}

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Address Address { get; set; }
    
    // Copy constructor
    public Person(Person other)
    {
        Name = other.Name;
        Age = other.Age;
        // Deep copy - create new Address object
        Address = new Address 
        { 
            Street = other.Address.Street,
            City = other.Address.City 
        };
    }
}

// Usage
var person1 = new Person 
{ 
    Name = "Alice", 
    Age = 30,
    Address = new Address { Street = "123 Main St", City = "NYC" }
};

var person2 = new Person(person1);  // Deep copy
person2.Address.City = "LA";

Console.WriteLine(person1.Address.City);  // NYC (unchanged!)
Console.WriteLine(person2.Address.City);  // LA
```

**Scenario 2: List/Collection Cloning**
```csharp
public class ShoppingCart
{
    public List<string> Items { get; set; }
    public decimal Total { get; set; }
    
    public ShoppingCart()
    {
        Items = new List<string>();
    }
    
    // Copy constructor
    public ShoppingCart(ShoppingCart other)
    {
        Items = new List<string>(other.Items);  // Create new list
        Total = other.Total;
    }
}

// Usage
var cart1 = new ShoppingCart();
cart1.Items.Add("Laptop");
cart1.Items.Add("Mouse");
cart1.Total = 1200;

var cart2 = new ShoppingCart(cart1);  // Copy
cart2.Items.Add("Keyboard");

Console.WriteLine(cart1.Items.Count);  // 2 (unchanged)
Console.WriteLine(cart2.Items.Count);  // 3
```

**Scenario 3: Immutable Object Pattern**
```csharp
public class Configuration
{
    public string Environment { get; }
    public int Timeout { get; }
    public bool EnableLogging { get; }
    
    public Configuration(string env, int timeout, bool logging)
    {
        Environment = env;
        Timeout = timeout;
        EnableLogging = logging;
    }
    
    // Copy constructor for creating modified versions
    public Configuration(Configuration other)
    {
        Environment = other.Environment;
        Timeout = other.Timeout;
        EnableLogging = other.EnableLogging;
    }
    
    // Create modified copy
    public Configuration WithTimeout(int newTimeout)
    {
        var copy = new Configuration(this);
        // Use reflection or init-only setters in real implementation
        return new Configuration(Environment, newTimeout, EnableLogging);
    }
}
```

---

## Quick Comparison Table

| Constructor Type | Main Purpose | Key Benefit |
|-----------------|--------------|-------------|
| **Private** | Control instantiation | Implement patterns (Singleton, Factory), prevent unwanted object creation |
| **Static** | Initialize static members once | Setup shared resources, configuration, one-time operations |
| **Copy** | Clone objects | Create independent copies, avoid reference sharing issues |

---

## Real-World Example Combining All Three

```csharp
public class CacheManager
{
    private static CacheManager instance;
    private static Dictionary<string, object> cache;
    
    // Static constructor - runs once
    static CacheManager()
    {
        cache = new Dictionary<string, object>();
        Console.WriteLine("Cache initialized");
    }
    
    // Private constructor - singleton pattern
    private CacheManager() { }
    
    public static CacheManager GetInstance()
    {
        if (instance == null)
            instance = new CacheManager();
        return instance;
    }
    
    public void Set(string key, object value) => cache[key] = value;
    public object Get(string key) => cache.ContainsKey(key) ? cache[key] : null;
}

public class CachedData
{
    public string Key { get; set; }
    public object Value { get; set; }
    public DateTime Timestamp { get; set; }
    
    // Copy constructor - for cloning cache entries
    public CachedData(CachedData other)
    {
        Key = other.Key;
        Value = other.Value;  // Shallow copy, use deep copy if needed
        Timestamp = other.Timestamp;
    }
}
```

Each constructor type solves specific problems and should be used when those patterns or requirements apply to your code.